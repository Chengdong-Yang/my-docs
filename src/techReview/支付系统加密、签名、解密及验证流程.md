---
# 这是文章的标题
title: 技术积累
# 你可以自定义封面图片
cover: /assets/images/cover1.jpg
# 这是页面的图标
icon: file
# 这是侧边栏的顺序
order: 1
# 设置作者
author: Ms.Hope
# 设置写作时间
date: 2020-01-01
# 一个页面可以有多个分类
category:
  - 技术积累
# 一个页面可以有多个标签
tag:
  - 页面配置
  - 使用指南
# 此页面会在文章列表置顶
sticky: true
# 此页面会出现在星标文章中
star: true
# 你可以自定义页脚
footer: 这是测试显示的页脚
# 你可以自定义版权信息
copyright: 无版权
---
# 支付系统加密签名流程

### **加密、签名、解密、验证流程详细说明**

在支付系统中，敏感信息（如支付金额、账户信息等）必须加密传输，确保数据不被篡改。此外，为了验证发送方的身份，通常还会对数据进行数字签名，防止数据在传输过程中被修改。整个流程分为以下几步：

1. **数据准备**
2. **加密（对称加密）**
3. **加密密钥保护（非对称加密）**
4. **生成数字签名**
5. **发送数据**
6. **接收方解密并验证签名**

### **步骤 1：数据准备**

假设商户 A 需要向支付系统发送一个支付请求。请求消息体包含敏感的交易信息，如支付金额、付款人账户等。

**例子**：

```java
{
"amount": "1000.00",
"payerAccount": "1234567890",
"orderId": "ORD123456789",
"timestamp": "2024-09-29T10:15:30Z"
}
```

这是一条支付请求，其中包含：

- **支付金额**：1000.00 元
- **付款人账户**：1234567890
- **订单号**：ORD123456789
- **时间戳**：交易的发起时间

这条消息包含了敏感的财务信息，必须加密处理。

### **步骤 2：加密消息体（对称加密）**

为了保护敏感数据不被窃取或篡改，商户 A 生成一个 **对称密钥**（例如 AES 密钥），并使用它对消息体进行加密。对称加密算法的特点是：同一个密钥既用于加密，也用于解密。

**加密过程**：

- 商户 A 生成一个 256 位的 AES 密钥。
- 使用这个 AES 密钥对消息体进行加密。

**加密后的消息体**（假设）：

`c29tZSBlbmNyeXB0ZWQgbWVzc2FnZQ==  （加密后的 Base64 编码内容）`

### **步骤 3：加密密钥保护（非对称加密）**

由于对称密钥（AES 密钥）也属于敏感信息，因此不能直接传输。商户 A 使用 **支付系统的公钥（非对称密钥）** 对这个 AES 密钥进行加密。非对称加密的特点是：公钥加密，私钥解密。

**加密过程**：

- 使用支付系统的公钥加密 AES 密钥，得到加密后的对称密钥。
- 将加密后的对称密钥放在消息头部的 `EncKey` 字段中。

**加密后的 AES 密钥**（假设）：

`R0lGODdhAQABAIAAAAUEBAAA... （用支付系统公钥加密后的密钥）`

**EncSN**：

- `EncSN` 是加密序列号，用来标识支付系统的公钥。

**EncKey**：

- `EncKey` 字段包含加密后的对称密钥，接收方将使用自己的私钥解密得到 AES 密钥，用于解密消息体。

### **步骤 4：生成数字签名**

为了验证消息的完整性和发送方的身份，商户 A 还需要对原始消息体进行数字签名。数字签名使用商户 A 的私钥生成，支付系统会使用商户 A 的公钥验证。

**签名过程**：

1. 使用摘要算法（如 SHA-256）计算消息体的摘要（即消息的哈希值）。
2. 使用商户 A 的私钥对摘要进行加密，生成数字签名。
3. 将生成的签名放在消息头的 `SignSN` 字段中。

**SignEncAlgo**：

- `SignEncAlgo` 指明使用的签名加密算法（例如 RSA）。
- `MDAlgo` 指明使用的消息摘要算法（如 SHA-256）。

**签名示例**（假设）：

```java
c2lnbmVkIGJ5IHByaXZhdGUga2V5  （使用商户 A 的私钥生成的数字签名）
```

### **步骤 5：发送数据**

经过上述处理，商户 A 将以下数据发送给支付系统：

- **消息体（加密后的）**：`c29tZSBlbmNyeXB0ZWQgbWVzc2FnZQ==`
- **加密的 AES 密钥（****EncKey****）**：`R0lGODdhAQABAIAAAAUEBAAA...`
- **加密序列号（****EncSN****）**：`SN123456`
- **数字签名（****SignSN****）**：`c2lnbmVkIGJ5IHByaXZhdGUga2V5`
- **签名算法（****SignEncAlgo****）**：`0`（表示 RSA）
- **摘要算法（****MDAlgo****）**：`SHA-256`
- **加密算法（****EncAlgo****）**：`AES-256`
-

### **步骤 6：接收方解密并验证签名**

支付系统收到上述数据后，按照以下步骤进行解密和验证。

#### **6.1 解密密钥**

支付系统使用自己的 **私钥** 解密消息头中的 `EncKey`，得到商户 A 使用的 **AES 密钥**。

#### **6.2 解密消息体**

支付系统使用解密得到的 AES 密钥和 `EncAlgo` 指定的算法（AES-256）解密消息体，恢复出原始的交易信息。

**解密后的消息体**：

```json
{
"amount": "1000.00",
"payerAccount": "1234567890",
"orderId": "ORD123456789",
"timestamp": "2024-09-29T10:15:30Z"
}
```

#### **6.3 验证签名**

为了确保消息在传输过程中没有被篡改，支付系统需要验证商户 A 的数字签名。验证过程如下：

1. 使用 `MDAlgo`（SHA-256）对解密后的消息体计算摘要。
2. 使用商户 A 的 **公钥** 对 `SignSN` 中的数字签名进行解密，得到商户 A 发送的摘要。
3. 比较两个摘要是否一致。

   - 如果一致，说明消息未被篡改。
   - 如果不一致，说明消息在传输过程中可能被修改。

---

### **完整的示例流程总结**

1. 商户 A 准备好支付请求消息，并生成一个 **AES 密钥** 对消息体进行加密。
2. 商户 A 使用支付系统的 **公钥** 加密 AES 密钥，将加密后的密钥放入 `EncKey` 字段中。
3. 商户 A 使用自己的 **私钥** 对消息体计算出的摘要进行签名，将签名结果放入 `SignSN` 字段中。
4. 支付系统接收消息后，使用自己的 **私钥** 解密 `EncKey`，获取 AES 密钥。
5. 支付系统使用 AES 密钥解密消息体，恢复原始的交易信息。
6. 支付系统使用商户 A 的 **公钥** 验证数字签名，确保消息未被篡改。

### **总结：各个字段的作用**

- **EncSN**：指示使用的密钥序列号，帮助支付系统找到对应的私钥解密 `EncKey`。
- **EncKey**：加密后的对称密钥（AES 密钥），用于解密消息体。
- **SignSN**：数字签名，确保消息的完整性和验证商户 A 的身份。
- **SignEncAlgo**：指定签名算法（如 RSA）。
- **MDAlgo**：指定消息摘要算法（如 SHA-256）。
- **EncAlgo**：指定加密算法（如 AES-256）。

### 提问：商户 a 的公钥和支付机构的公钥什么时候给的？

以下是商户 A 与支付机构之间公钥交换的标准流程，帮助您理解密钥管理在系统初始化时如何进行：

#### **3.1 商户 A 注册并建立密钥**

1. **商户 A 生成密钥对（公钥和私钥）**

   - 当商户 A 初次注册支付系统时，需要为自己生成一对 **非对称密钥对（RSA 或 ECC）**。
   - 商户 A 生成自己的 **私钥和公钥**：
     - **私钥** 只能由商户 A 自己保管，永不外传。
     - **公钥** 可以公开，用于支付机构验证商户 A 的签名。
2. **商户 A 将公钥提供给支付机构**

   - 商户 A 可以通过**安全渠道**（例如使用 HTTPS 上传、线下交付等）将公钥提供给支付机构。
   - 支付机构将商户 A 的公钥保存在其数据库中，并与商户 A 的身份信息进行绑定。
3. **支付机构将公钥证书提供给商户 A**

   - 支付机构通常使用 **CA 证书（Certificate Authority）** 来签发自己的公钥证书（`*.cer` 或 `*.pem` 格式）。
   - 支付机构将公钥证书通过安全渠道（如 HTTPS 下载链接、线下交付等）提供给商户 A。
   - 商户 A 将支付机构的公钥证书导入到其系统中，用于后续加密操作。
